# 基础知识之类的不变式

> **不变式**究竟是个什么样子，很多程序员搞了很多年也并没有完全搞清楚，可能某些人的思路比较好（迫真），搞了些getter setter范式，但是后面就搞僵化了。

# 前言
　　这个入门级概念我想对于科班出来的程序员应该是学校上程序设计或者数据结构时就会介绍。不过本人的带学老师反正是从未提及（当然我c++后面几节课全翘了，可能是我没听到。不过老师提访问控制时确实没怎么介绍过）。数据结构本来是维持不变式的典例，但是学校用的远古教材里都还是Fortran改的c语言代码，故又没有提及（当然这个也不应该是数据结构的教学重点）。据我对其他我共事过的同学和某些网友的了解，这部分人中也有不少对不变式这个概念毫不了解，也有认为万物都不应当设访问控制的~~暴露癖仙人~~。而这些人中有的写的代码，包括我用过的某几个库，往往因为完全的公开访问控制（当然c库的结构体也只能这样，不能苛责它），或者无端的private，把使用的负担都压到了调库的人身上。
　　所以写这篇文章，是希望看了它的人再写代码不要搞一些唐氏一样的getter setter函数，或者把一些应该封闭的变量直接暴露出来。<u>而如果你已经认为了解了，或者上班了，或者写过某些大项目再或者对能力很自信，应该可以直接退出了，避免下面吹水的基础内容占用你宝贵的时间</u>。
　　这篇文章尽管是基于c++来说的，但是核心内容不会对和c++有密切关联的东西有所提及（而且这些东西大概也被别的能人讲烂了），所以我会尽量规避析构函数、所有权、堆分配和异常之类的东西，让案例更泛化。不过我会推荐一点c++编程中的个人做法。
　　

# 什么是不变式

类的不变式（Class Invariant）是面向对象编程中的一个重要概念，它描述了**类的对象在其生命周期内必须始终保持满足的条件或约束**。这些条件定义了对象的有效状态，确保无论对象如何被修改（通过方法调用或属性变更），其内部状态始终合法且符合设计预期。

基本上就是你不能乱改某个数据成员，因为它和其它的某个数据成员可能原本具有某种关系；而外部随意的修改会破坏这种关系，导致程序后续运行出现bug，除非这种关系得到修正。

---

### **核心特点**：
1. **始终成立**（Exceptional Moment）：
   - 不变式必须在对象的所有**公开方法调用前和执行后**成立。唯一例外的是对象内部方法执行过程中可能暂时破坏不变式，但必须在成员函数结束前恢复有效状态。


2. **约束对象状态**：
   - 不变式通常涉及类的成员变量之间的关系。例如：
     - 在表示日期的类中，月份必须介于 `1` 和 `12` 之间。
     - 在表示银行账户的类中，余额不能为负数。


3. **与封装性相关**：
   - 不变式通过**封装**来维护，即通过限制对成员变量的直接访问，强制所有状态变更必须经过验证



# 案例

## 成员相互正交的纯数据类型
正交（orthogonal），这里即不相关。最纯粹的例子如下：
``` cpp
struct vec2{
　　float x;
　　float y;
};
```
通常来说这种纯数据类型也就只是给一堆变量弄在一起然后起了个名字而已。
我相信应该不会有人对这个例子有异议，向量的两个自由度在通常语境下总应该是不相关的。这两个数据成员相互之间不构成任何联系，这个结构体也因此不存在任何不变式。不存在不变式，所以用户应当有权利随意更改它的任意一个成员，而不必同时维系其它成员的值。
所以`x`，`y`在这里应当具有公开（*public*）访问控制，不需要通过任何函数来进行访问或者修改。

在c++中，这种类型不光应该保证完全的公开访问控制，而且不建议具有构造函数或显式指定为default的构造函数（除非你写的构造函数确实能减轻你的工作量），c++20的**指派初始化**一般足够应对这种类型。如果你不需要指定某些常用默认值（比如缩放默认为1，某些bool默认为true等），那么尽量不要为每个成员提供默认初始化器（不过如果提供，建议所有成员都提供）。对于这个向量的例子，我强烈建议它是平凡（trivial）类型。这对关于小对象的优化非常重要。简单的说，你自己写的类特殊函数越少越好。

## 成员不相互正交或类存在不变式的例子：
### 类本身需要维持不变式：
``` cpp
struct rect_ortho{//这的正交其实是AABB的意思，即各边平行坐标轴
public:
　　vec2 src{};
private:
　　vec2 size_{};
public:
　　void set_width(float w){
　　　　if(w < 0){
　　　　　　src.x += w;
　　　　　　size_.x = -w;
　　　　}else{
　　　　　　size_.x = w;
　　　　}
　　}

　　void set_height(float h){
　　　　if(h < 0){
　　　　　　src.y += h;
　　　　　　size_.y = -h;
　　　　}else{
　　　　　　size_.y = h;
　　　　}
　　}
　　
　　vec2 size() const {
　　　　return size_;
　　}
};
```
这是我自己做游戏的时候用的AABB矩形类：注意到这个类本身需要维持一个不变式：size_的各分量非负。
这带来一个好处即src始终位于左下角，而src + size_的各分量各不小于src，即通常位于右上角。这使得各种相交检测变得更加快速。
这种情况下，各类型成员相互之间不存在关系，而size_本身因类的特殊性需要维持不变式。所以size_不应该具有public的访问权限：用户可能会赋给size_一个某分量为负的数，导致后续代码出现问题。
所以为了设置size_，两个setter函数就有了存在的必要性：用户应该通过它来修改size_，并方便地将负分量运用到src上而不报出错误；与此相对的，src本身不具备需要维护的约束，所以它是public的，用户可以随意修改它。

在c++中，对应上面所说，为了维护不变式，你不能再使用指派初始化了，而且这里的矩形其实也有表达限制，比如可能真的有人想要一个size_为(-inf, -inf)的矩形。这时候这个矩形就抽象泄露了。我在写这东西的代码时msvc还不完全支持显式this参数，现在再改也很麻烦，留下了一个缺憾：其实更好的做法应该提供一个不存在任何不变式的矩形类，它的size可以为负，同时提供使用deducing this的setter函数；而一个可能叫positive_size_rect的矩形类private继承它，同时通过using暴露出src，并重写setter（准确的说是shadow基类的对应setter）和一个用户定义的转换到基类的operator rect() const{...}和从基类构造的构造函数。这样用户得以根据情况使用两种矩形，方便相互转换，还能保证基类矩形是trivial的，且支持编译期多态。


### 成员不相互正交：
代码：
``` cpp
struct quad{
private:
　　vec2 v0_{}, v1_{}, v2_{}, v3_{};
　　rect_ortho bound_{};
public:
　　set_verts(vec2 v0, vec2 v1, vec2 v2, vec2 v3){
　　　　v0_ = v0;
　　　　v1_ = v1;
　　　　v2_ = v2;
　　　　v3_ = v3;
　　　　auto [sx, dx] = std::minmax({v0.x, v1.x, v2.x,  v3.x});
　　　　auto [sy, dy] = std::minmax({v0.y, v1.y, v2.y,  v3.y});
　　　　bound.src = {sx, sy};
　　　　bound.set_width(dx - sx);
　　　　bound.set_height(dy - sy);
　　}
　　
　　//getters …
};
```
这是一个任意四边形，它的四个顶点和其包围盒bound形成关系。现在这四个顶点和包围盒构成不变式，用户不应该修改它的顶点或者包围盒，否则可能导致包围盒不能恰好包围这四个顶点。故这五个成员变量都为private。对应的，用户应该提供一个函数来设置顶点。同时，由于包围盒直接由这四个顶点产生，所以包围盒不应具有单独的setter或作为其它setter中的参数。
注意到bound其实可以是即可计算的：你可以写一个get_bound函数来主动计算包围盒，这样节省了空间，使得各顶点可以直接作为public成员，但加大了耗时。游戏中碰撞检测是性能敏感部分，所以直接缓存包围盒是我更认可的做法。

当然，如果你写的是c++，那可以再用上面对rect提供的解决方案：写一个无缓存的四边形类，一个类私有或保护继承它并提供缓存，在基类中提供deducing this的get_bound函数主动计算包围盒，在派生类中直接返回缓存。这样就两全其美了。

# 总结
- 若成员间相互正交，则保持公开，简化访问。  
- 若存在约束关系等不变式，严格封装，通过成员函数管理状态。  
- 避免无脑的 `getter/setter`，仅在必要时使用。  
- 权衡性能与封装（如主动缓存）。  
代码应清晰表达设计意图，减少调用方负担，同时保持高效可靠。不过对于库作者来说，如果你出于某些原因需要隐藏成员（比如出于隐藏实现的目的或者pimpl范式）使用private+getter/setter也是可取的。
